#include "../include/log.h"
#include <iostream>
#include <chrono>
#include <ctime>
#include <thread>
#include <mutex>
#include <queue>
#include <condition_variable>
#include "../include/tool.h"

using namespace std;

// ???????????????
Logger* Logger::instance = nullptr;

// ??????????????????
string Logger::logLevelToString(LogLevel level) {
    switch (level) {
    case LogLevel::INFO: return "INFO";
    case LogLevel::WARNING: return "WARNING";
    case LogLevel::ERROR_: return "ERROR_";
    case LogLevel::FATAL: return "FATAL";
    default: return "UNKNOWN";
    }
}

// ???????????????
string Logger::createLogMessage(LogLevel level, const string& origin, const string& message) {
    return "[" + time_::getCurrentTime() + "] [" + logLevelToString(level) + "] [" + origin + "] " + message;
}

// ???????д????????????
void Logger::writeLogToFile(const string& logMessage) {
    lock_guard<mutex> lock(mtx);  // ?????????????????

    // ?????????????????????
    logfile.createNewFile(logPath, logFilename);

    // д??????????
    logfile.appendToLastLine(logPath, logFilename, logMessage);
    cout << logMessage << endl;
}

// ?????????
void Logger::logThreadFunction() {
    while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [this]() { return !logQueue.empty() || stopLogging; });

        // ??????????????????????????
        if (stopLogging && logQueue.empty()) {
            break;
        }

        // ????????е??????????
        string logMessage = logQueue.front();
        logQueue.pop();
        logCount--;  // ??????????????????????????
        lock.unlock();  // ??????????????????????

        // д?????
        writeLogToFile(logMessage);
    }
}

// ??й?????????????????????? Logger ???
Logger::Logger(const string& path, const string& filename) : logPath(path), logFilename(filename) {
    // ??????????
    logfile.createNewFile(logPath, logFilename);
}

// ??????Ψ??? Logger ???
Logger& Logger::getInstance() {
    if (instance == nullptr) {
        // ????·?????????????
        instance = new Logger(LOGPATH, LOGNAME);
        instance->start();  // ??????????
    }
    return *instance;
}

// ??????????
void Logger::start() {
    logThread = thread(&Logger::logThreadFunction, this);  // ??????????
}

// ??????????????????????????????
void Logger::stop() {
    {
        lock_guard<mutex> lock(mtx);
        stopLogging = true;
    }
    cv.notify_all();  // ???????????

    // ?????????????????
    while (logCount > 0) {
        this_thread::sleep_for(chrono::milliseconds(10));  // ???????????????
    }

    if (logThread.joinable()) {
        logThread.join();  // ????????????
    }
}

// ??????????·??
void Logger::setLogPath(const string& newPath) {
    lock_guard<mutex> lock(mtx);  // ????????
    logPath = newPath;
    // ??????????????????????????
    logfile.createNewFile(logPath, logFilename);
}

// ???????????????
void Logger::setLogFilename(const string& newFilename) {
    lock_guard<mutex> lock(mtx);  // ????????
    logFilename = newFilename;
    // ??????????????????????????
    logfile.createNewFile(logPath, logFilename);
}

// д??????????????
void Logger::logInfo(const string& origin, const string& message) {
    string logMessage = createLogMessage(LogLevel::INFO, origin, message);
    {
        lock_guard<mutex> lock(mtx);
        logQueue.push(logMessage);
        logCount++;  // ?????????????????
    }
    cv.notify_all();  // ???????????
}

// д??????????漶??
void Logger::logWarning(const string& origin, const string& message) {
    string logMessage = createLogMessage(LogLevel::WARNING, origin, message);
    {
        lock_guard<mutex> lock(mtx);
        logQueue.push(logMessage);
        logCount++;  // ?????????????????
    }
    cv.notify_all();  // ???????????
}

// д????????????
void Logger::logError(const string& origin, const string& message) {
    string logMessage = createLogMessage(LogLevel::ERROR_, origin, message);
    {
        lock_guard<mutex> lock(mtx);
        logQueue.push(logMessage);
        logCount++;  // ?????????????????
    }
    cv.notify_all();  // ???????????
}

// д????????????????
void Logger::logFatal(const string& origin, const string& message) {
    string logMessage = createLogMessage(LogLevel::FATAL, origin, message);
    {
        lock_guard<mutex> lock(mtx);
        logQueue.push(logMessage);
        logCount++;  // ?????????????????
    }
    cv.notify_all();  // ???????????
}
